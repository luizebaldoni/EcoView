<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models.py" />
              <option name="originalContent" value="from django.db import models&#10;from django.utils import timezone&#10;&#10;class SensorReading(models.Model):&#10;&#9;timestamp = models.DateTimeField(default = timezone.now)&#10;&#9;&#10;&#9;# Sensores genéricos - você pode adaptar aos seus sensores específicos&#10;&#9;sensor1 = models.FloatField()&#10;&#9;sensor2 = models.FloatField()&#10;&#9;sensor3 = models.FloatField()&#10;&#9;sensor4 = models.FloatField()&#10;&#9;sensor5 = models.FloatField()&#10;&#9;sensor6 = models.FloatField()&#10;&#9;sensor7 = models.FloatField()&#10;&#9;sensor8 = models.FloatField()&#10;&#9;sensor9 = models.FloatField()&#10;&#9;sensor10 = models.FloatField()&#10;&#9;sensor11 = models.FloatField()&#10;&#9;sensor12 = models.FloatField()&#10;&#9;sensor13 = models.FloatField()&#10;&#9;&#10;&#9;# Campos adicionais se necessário&#10;&#9;device_id = models.CharField(max_length = 50, blank = True, null = True)&#10;&#9;battery_level = models.FloatField(blank = True, null = True)&#10;&#9;&#10;&#9;def __str__(self):&#10;&#9;&#9;return f&quot;Leitura em {self.timestamp}&quot;&#10;&#9;&#10;&#9;class Meta:&#10;&#9;&#9;ordering = ['-timestamp']" />
              <option name="updatedContent" value="from django.db import models&#10;from django.utils import timezone&#10;&#10;class SensorReading(models.Model):&#10;&#9;timestamp = models.DateTimeField(default = timezone.now)&#10;&#9;&#10;&#9;# Sensores genéricos - você pode adaptar aos seus sensores específicos&#10;&#9;sensor1 = models.FloatField()&#10;&#9;sensor2 = models.FloatField()&#10;&#9;sensor3 = models.FloatField()&#10;&#9;sensor4 = models.FloatField()&#10;&#9;sensor5 = models.FloatField()&#10;&#9;sensor6 = models.FloatField()&#10;&#9;sensor7 = models.FloatField()&#10;&#9;sensor8 = models.FloatField()&#10;&#9;sensor9 = models.FloatField()&#10;&#9;sensor10 = models.FloatField()&#10;&#9;sensor11 = models.FloatField()&#10;&#9;sensor12 = models.FloatField()&#10;&#9;sensor13 = models.FloatField()&#10;&#9;&#10;&#9;# Campos adicionais se necessário&#10;&#9;device_id = models.CharField(max_length = 50, blank = True, null = True)&#10;&#9;battery_level = models.FloatField(blank = True, null = True)&#10;&#9;&#10;&#9;def __str__(self):&#10;&#9;&#9;return f&quot;{self.device_id} - {self.timestamp.strftime('%Y-%m-%d %H:%M:%S')}&quot;&#10;&#9;&#10;&#9;class Meta:&#10;&#9;&#9;ordering = ['-timestamp']" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/urls.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/urls.py" />
              <option name="originalContent" value="from django.urls import path&#10;from app.views import *&#10;&#10;urlpatterns = [&#10;&#9;path('', HomeView.as_view(), name='home'),&#10;    path('api/receive/', receive_sensor_data, name= 'receive_sensor_data'),&#10;    path('', dashboard, name= 'dashboard'),&#10;    path('table/', data_table, name= 'data_table'),&#10;&#9;&#10;]" />
              <option name="updatedContent" value="from django.urls import path&#10;from app.views import *&#10;&#10;urlpatterns = [&#10;&#9;path('', HomeView.as_view(), name='home'),&#10;    path('api/receive/', receive_sensor_data, name= 'receive_sensor_data'),&#10;    path('dashboard/', dashboard, name= 'dashboard'),&#10;    path('table/', data_table, name= 'data_table'),&#10;&#9;&#10;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/views.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/views.py" />
              <option name="originalContent" value="import json&#10;import traceback&#10;from datetime import timedelta&#10;from venv import logger&#10;&#10;from django.core.paginator import Paginator&#10;from django.db.models import Avg, Max, Min&#10;from django.http import JsonResponse&#10;from django.shortcuts import render&#10;from django.utils import timezone&#10;from rest_framework.renderers import *&#10;from rest_framework.request import *&#10;from rest_framework.views import *&#10;&#10;from config import settings&#10;from .models import SensorReading&#10;&#10;&#10;class HomeView(APIView):&#10;    renderer_classes = [TemplateHTMLRenderer]&#10;    template_name = 'base.html'&#10;&#10;    def get(self, request):&#10;        context = {&#10;            'title': 'Sensor Monitoring System',&#10;            'description': 'Welcome to the sensor data monitoring platform',&#10;            'features': [&#10;                'Real-time sensor data visualization',&#10;                'Historical data analysis',&#10;                'Device management',&#10;                'API endpoints for integration'&#10;            ],&#10;            'api_endpoints': [&#10;                {'name': 'Sensor Data API', 'url': '/api/receive/', 'method': 'POST'},&#10;                {'name': 'Dashboard', 'url': '/dashboard/', 'method': 'GET'},&#10;                {'name': 'Data Table', 'url': '/table/', 'method': 'GET'}&#10;            ]&#10;        }&#10;        return Response(context, status=status.HTTP_200_OK)&#10;@csrf_exempt&#10;def receive_sensor_data(request):&#10;    &quot;&quot;&quot;&#10;    API endpoint to receive sensor data from ESP32 devices&#10;    Expected JSON format:&#10;    {&#10;        &quot;sensor1&quot;: value, &quot;sensor2&quot;: value, ..., &quot;sensor13&quot;: value,&#10;        &quot;device_id&quot;: string,&#10;        &quot;battery&quot;: float (0-100)&#10;    }&#10;    &quot;&quot;&quot;&#10;    if request.method != 'POST':&#10;        return JsonResponse(&#10;                {'status': 'error', 'message': 'Only POST method is allowed'},&#10;                status = 405&#10;                )&#10;    &#10;    try:&#10;        # Parse and validate JSON data&#10;        try:&#10;            data = json.loads(request.body.decode('utf-8'))&#10;        except json.JSONDecodeError:&#10;            return JsonResponse(&#10;                    {'status': 'error', 'message': 'Invalid JSON format'},&#10;                    status = 400&#10;                    )&#10;        &#10;        # Validate required fields&#10;        required_fields = [f'sensor{i}' for i in range(1, 14)] + ['device_id']&#10;        missing_fields = [field for field in required_fields if field not in data]&#10;        &#10;        if missing_fields:&#10;            return JsonResponse(&#10;                    {'status': 'error', 'message': f'Missing required fields: {&quot;, &quot;.join(missing_fields)}'},&#10;                    status = 400&#10;                    )&#10;        &#10;        # Validate sensor values&#10;        try:&#10;            sensor_data = {&#10;                    f'sensor{i}': float(data[f'sensor{i}'])&#10;                    for i in range(1, 14)&#10;                    }&#10;        except (ValueError, TypeError):&#10;            return JsonResponse(&#10;                    {'status': 'error', 'message': 'All sensor values must be numbers'},&#10;                    status = 400&#10;                    )&#10;        &#10;        # Validate battery level&#10;        battery_level = float(data.get('battery', 0))&#10;        if not 0 &lt;= battery_level &lt;= 100:&#10;            return JsonResponse(&#10;                    {'status': 'error', 'message': 'Battery level must be between 0 and 100'},&#10;                    status = 400&#10;                    )&#10;        &#10;        # Create and save new reading&#10;        reading = SensorReading(&#10;                timestamp = timezone.now(),&#10;                device_id = data['device_id'],&#10;                battery_level = battery_level,&#10;                **sensor_data&#10;                )&#10;        reading.save()&#10;        &#10;        return JsonResponse({&#10;                'status': 'success',&#10;                'message': 'Data saved successfully',&#10;                'reading_id': reading.id,&#10;                'timestamp': reading.timestamp.isoformat()&#10;                })&#10;    &#10;    except Exception as e:&#10;        # Log the error for debugging&#10;        import logging&#10;        logger = logging.getLogger(__name__)&#10;        logger.error(f&quot;Error processing sensor data: {str(e)}&quot;, exc_info = True)&#10;        &#10;        return JsonResponse(&#10;                {'status': 'error', 'message': 'Internal server error'},&#10;                status = 500&#10;                )&#10;&#10;def dashboard(request):&#10;&#9;&quot;&quot;&quot;&#10;&#9;Dashboard view showing charts and summary of last 24 hours&#10;&#9;&quot;&quot;&quot;&#10;&#9;try:&#10;&#9;&#9;# Get data from last 24 hours&#10;&#9;&#9;time_threshold = timezone.now() - timedelta(hours = 24)&#10;&#9;&#9;readings = SensorReading.objects.filter(&#10;&#9;&#9;&#9;&#9;timestamp__gte = time_threshold&#10;&#9;&#9;&#9;&#9;).order_by('timestamp')&#10;&#9;&#9;&#10;&#9;&#9;# Get summary statistics&#10;&#9;&#9;summary = {&#10;&#9;&#9;&#9;&#9;'temperature': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;'current': readings.last().sensor1 if readings.exists() else None,&#10;&#9;&#9;&#9;&#9;&#9;&#9;'avg': readings.aggregate(Avg('sensor1'))['sensor1__avg'],&#10;&#9;&#9;&#9;&#9;&#9;&#9;'max': readings.aggregate(Max('sensor1'))['sensor1__max'],&#10;&#9;&#9;&#9;&#9;&#9;&#9;'min': readings.aggregate(Min('sensor1'))['sensor1__min']&#10;&#9;&#9;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;&#9;'humidity': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;'current': readings.last().sensor7 if readings.exists() else None,&#10;&#9;&#9;&#9;&#9;&#9;&#9;'avg': readings.aggregate(Avg('sensor7'))['sensor7__avg'],&#10;&#9;&#9;&#9;&#9;&#9;&#9;'max': readings.aggregate(Max('sensor7'))['sensor7__max'],&#10;&#9;&#9;&#9;&#9;&#9;&#9;'min': readings.aggregate(Min('sensor7'))['sensor7__min']&#10;&#9;&#9;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;&#9;'battery': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;'current': readings.last().battery_level if readings.exists() else None,&#10;&#9;&#9;&#9;&#9;&#9;&#9;'avg': readings.aggregate(Avg('battery_level'))['battery_level__avg'],&#10;&#9;&#9;&#9;&#9;&#9;&#9;'min': readings.aggregate(Min('battery_level'))['battery_level__min']&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#10;&#9;&#9;context = {&#10;&#9;&#9;&#9;&#9;'readings': readings,&#10;&#9;&#9;&#9;&#9;'summary': summary,&#10;&#9;&#9;&#9;&#9;'sensor_names': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;1: &quot;Temperatura Externa 1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;2: &quot;Temperatura Externa 2&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;3: &quot;Temperatura Solo 1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;4: &quot;Temperatura Solo 2&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;5: &quot;Temperatura Ar 1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;6: &quot;Temperatura Ar 2&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;7: &quot;Umidade Ar 1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;8: &quot;Umidade Ar 2&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;9: &quot;Umidade Solo&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;10: &quot;Radiação UV 1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;11: &quot;Radiação UV 2&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;12: &quot;Velocidade Vento 1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;13: &quot;Velocidade Vento 2&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;&#9;'units': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;1: &quot;°C&quot;, 2: &quot;°C&quot;, 3: &quot;°C&quot;, 4: &quot;°C&quot;, 5: &quot;°C&quot;, 6: &quot;°C&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;7: &quot;%&quot;, 8: &quot;%&quot;, 9: &quot;%&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;10: &quot;UV&quot;, 11: &quot;UV&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;12: &quot;m/s&quot;, 13: &quot;m/s&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;return render(request, 'dashboard.html', context)&#10;&#9;&#10;&#9;except Exception as e:&#10;&#9;&#9;import logging&#10;&#9;&#9;logger = logging.getLogger(__name__)&#10;&#9;&#9;logger.error(f&quot;Error in dashboard view: {str(e)}&quot;, exc_info = True)&#10;&#9;&#9;return render(request, 'error.html', {'error': str(e)})&#10;&#10;&#10;def data_table(request):&#10;&#9;&quot;&quot;&quot;&#10;&#9;View showing paginated table with all sensor readings&#10;&#9;&quot;&quot;&quot;&#10;&#9;try:&#10;&#9;&#9;all_readings = SensorReading.objects.all().order_by('-timestamp')&#10;&#9;&#9;&#10;&#9;&#9;# Pagination - 50 items per page&#10;&#9;&#9;paginator = Paginator(all_readings, 50)&#10;&#9;&#9;page_number = request.GET.get('page')&#10;&#9;&#9;page_obj = paginator.get_page(page_number)&#10;&#9;&#9;&#10;&#9;&#9;context = {&#10;&#9;&#9;&#9;&#9;'page_obj': page_obj,&#10;&#9;&#9;&#9;&#9;'sensor_names': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;1: &quot;Temp 1&quot;, 2: &quot;Temp 2&quot;, 3: &quot;Temp 3&quot;, 4: &quot;Temp 4&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;5: &quot;Temp 5&quot;, 6: &quot;Temp 6&quot;, 7: &quot;Hum 1&quot;, 8: &quot;Hum 2&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;9: &quot;Hum 3&quot;, 10: &quot;UV 1&quot;, 11: &quot;UV 2&quot;, 12: &quot;Vento 1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;13: &quot;Vento 2&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;&#9;'units': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;1: &quot;°C&quot;, 2: &quot;°C&quot;, 3: &quot;°C&quot;, 4: &quot;°C&quot;, 5: &quot;°C&quot;, 6: &quot;°C&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;7: &quot;%&quot;, 8: &quot;%&quot;, 9: &quot;%&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;10: &quot;UV&quot;, 11: &quot;UV&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;12: &quot;m/s&quot;, 13: &quot;m/s&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;return render(request, 'data_table.html', context)&#10;&#9;&#10;&#9;except Exception as e:&#10;&#9;&#9;import logging&#10;&#9;&#9;logger = logging.getLogger(__name__)&#10;&#9;&#9;logger.error(f&quot;Error in data_table view: {str(e)}&quot;, exc_info = True)&#10;&#9;&#9;return render(request, 'error.html', {'error': str(e)})&#10;&#10;&#10;def custom_error_view(request, exception = None):&#10;&#9;&quot;&quot;&quot;&#10;&#9;Custom error view that shows detailed technical information for debugging,&#10;&#9;while maintaining a user-friendly interface.&#10;&#9;&quot;&quot;&quot;&#10;&#9;# Get exception information&#10;&#9;exc_type, exc_value, exc_traceback = sys.exc_info()&#10;&#9;error_traceback = traceback.format_exception(exc_type, exc_value, exc_traceback)&#10;&#9;&#10;&#9;# Build context with detailed error information&#10;&#9;context = {&#10;&#9;&#9;&#9;'error_type': exc_type.__name__ if exc_type else 'Unknown Error',&#10;&#9;&#9;&#9;'error_message': str(exc_value) if exc_value else 'No error message available',&#10;&#9;&#9;&#9;'error_traceback': error_traceback,&#10;&#9;&#9;&#9;'timestamp': timezone.now(),&#10;&#9;&#9;&#9;'request_path': request.path,&#10;&#9;&#9;&#9;'request_method': request.method,&#10;&#9;&#9;&#9;'debug_mode': settings.DEBUG,&#10;&#9;&#9;&#9;}&#10;&#9;&#10;&#9;# Add additional debug information if in DEBUG mode&#10;&#9;if settings.DEBUG:&#10;&#9;&#9;from django.http import QueryDict&#10;&#9;&#9;context.update({&#10;&#9;&#9;&#9;&#9;'request_headers': dict(request.headers),&#10;&#9;&#9;&#9;&#9;'request_params': QueryDict(request.META.get('QUERY_STRING', '')),&#10;&#9;&#9;&#9;&#9;'request_post': request.POST if request.method == 'POST' else None,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#10;&#9;# Determine the status code&#10;&#9;status_code = 500&#10;&#9;if hasattr(exception, 'status_code'):&#10;&#9;&#9;status_code = exception.status_code&#10;&#9;context['status_code'] = status_code&#10;&#9;&#10;&#9;# Log the error&#10;&#9;logger.error(&#10;&#9;&#9;&#9;f&quot;Error {status_code} at {request.path}\n&quot;&#10;&#9;&#9;&#9;f&quot;Type: {context['error_type']}\n&quot;&#10;&#9;&#9;&#9;f&quot;Message: {context['error_message']}\n&quot;&#10;&#9;&#9;&#9;f&quot;Traceback:\n{''.join(error_traceback)}&quot;&#10;&#9;&#9;&#9;)&#10;&#9;&#10;&#9;return render(request, 'error.html', context, status = status_code)" />
              <option name="updatedContent" value="import json&#10;import traceback&#10;from datetime import timedelta&#10;from venv import logger&#10;&#10;from django.core.paginator import Paginator&#10;from django.db.models import Avg, Max, Min&#10;from django.http import JsonResponse&#10;from django.shortcuts import render&#10;from django.utils import timezone&#10;from rest_framework.renderers import *&#10;from rest_framework.request import *&#10;from rest_framework.views import *&#10;&#10;from config import settings&#10;from .models import SensorReading&#10;&#10;&#10;class HomeView(APIView):&#10;    renderer_classes = [TemplateHTMLRenderer]&#10;    template_name = 'base.html'&#10;&#10;    def get(self, request):&#10;        context = {&#10;            'title': 'Sensor Monitoring System',&#10;            'description': 'Welcome to the sensor data monitoring platform',&#10;            'features': [&#10;                'Real-time sensor data visualization',&#10;                'Historical data analysis',&#10;                'Device management',&#10;                'API endpoints for integration'&#10;            ],&#10;            'api_endpoints': [&#10;                {'name': 'Sensor Data API', 'url': '/api/receive/', 'method': 'POST'},&#10;                {'name': 'Dashboard', 'url': '/dashboard/', 'method': 'GET'},&#10;                {'name': 'Data Table', 'url': '/table/', 'method': 'GET'}&#10;            ]&#10;        }&#10;        return Response(context, status=status.HTTP_200_OK)&#10;@csrf_exempt&#10;def receive_sensor_data(request):&#10;    &quot;&quot;&quot;&#10;    API endpoint to receive sensor data from ESP32 devices&#10;    Expected JSON format:&#10;    {&#10;        &quot;sensor1&quot;: value, &quot;sensor2&quot;: value, ..., &quot;sensor13&quot;: value,&#10;        &quot;device_id&quot;: string,&#10;        &quot;battery&quot;: float (0-100)&#10;    }&#10;    &quot;&quot;&quot;&#10;    if request.method != 'POST':&#10;        return JsonResponse(&#10;                {'status': 'error', 'message': 'Only POST method is allowed'},&#10;                status = 405&#10;                )&#10;    &#10;    try:&#10;        # Parse and validate JSON data&#10;        try:&#10;            data = json.loads(request.body.decode('utf-8'))&#10;        except json.JSONDecodeError:&#10;            return JsonResponse(&#10;                    {'status': 'error', 'message': 'Invalid JSON format'},&#10;                    status = 400&#10;                    )&#10;        &#10;        # Validate required fields&#10;        required_fields = [f'sensor{i}' for i in range(1, 14)] + ['device_id']&#10;        missing_fields = [field for field in required_fields if field not in data]&#10;        &#10;        if missing_fields:&#10;            return JsonResponse(&#10;                    {'status': 'error', 'message': f'Missing required fields: {&quot;, &quot;.join(missing_fields)}'},&#10;                    status = 400&#10;                    )&#10;        &#10;        # Validate sensor values&#10;        try:&#10;            sensor_data = {&#10;                    f'sensor{i}': float(data[f'sensor{i}'])&#10;                    for i in range(1, 14)&#10;                    }&#10;        except (ValueError, TypeError):&#10;            return JsonResponse(&#10;                    {'status': 'error', 'message': 'All sensor values must be numbers'},&#10;                    status = 400&#10;                    )&#10;        &#10;        # Validate battery level&#10;        battery_level = float(data.get('battery', 0))&#10;        if not 0 &lt;= battery_level &lt;= 100:&#10;            return JsonResponse(&#10;                    {'status': 'error', 'message': 'Battery level must be between 0 and 100'},&#10;                    status = 400&#10;                    )&#10;        &#10;        # Create and save new reading&#10;        reading = SensorReading(&#10;                timestamp = timezone.now(),&#10;                device_id = data['device_id'],&#10;                battery_level = battery_level,&#10;                **sensor_data&#10;                )&#10;        reading.save()&#10;        &#10;        return JsonResponse({&#10;                'status': 'success',&#10;                'message': 'Data saved successfully',&#10;                'reading_id': reading.id,&#10;                'timestamp': reading.timestamp.isoformat()&#10;                })&#10;    &#10;    except Exception as e:&#10;        # Log the error for debugging&#10;        import logging&#10;        logger = logging.getLogger(__name__)&#10;        logger.error(f&quot;Error processing sensor data: {str(e)}&quot;, exc_info = True)&#10;        &#10;        return JsonResponse(&#10;                {'status': 'error', 'message': 'Internal server error'},&#10;                status = 500&#10;                )&#10;&#10;def dashboard(request):&#10;    &quot;&quot;&quot;&#10;    Dashboard view showing charts and summary of last 24 hours&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get data from last 24 hours&#10;        time_threshold = timezone.now() - timedelta(hours=24)&#10;        readings = SensorReading.objects.filter(&#10;            timestamp__gte=time_threshold&#10;        ).order_by('timestamp')&#10;        &#10;        # Get summary statistics&#10;        summary = {&#10;                'temperature': {&#10;                        'current': readings.last().sensor1 if readings.exists() else None,&#10;                        'avg': readings.aggregate(Avg('sensor1'))['sensor1__avg'],&#10;                        'max': readings.aggregate(Max('sensor1'))['sensor1__max'],&#10;                        'min': readings.aggregate(Min('sensor1'))['sensor1__min']&#10;                        },&#10;                'humidity': {&#10;                        'current': readings.last().sensor7 if readings.exists() else None,&#10;                        'avg': readings.aggregate(Avg('sensor7'))['sensor7__avg'],&#10;                        'max': readings.aggregate(Max('sensor7'))['sensor7__max'],&#10;                        'min': readings.aggregate(Min('sensor7'))['sensor7__min']&#10;                        },&#10;                'battery': {&#10;                        'current': readings.last().battery_level if readings.exists() else None,&#10;                        'avg': readings.aggregate(Avg('battery_level'))['battery_level__avg'],&#10;                        'min': readings.aggregate(Min('battery_level'))['battery_level__min']&#10;                        }&#10;                }&#10;        &#10;        context = {&#10;                'readings': readings,&#10;                'summary': summary,&#10;                'sensor_names': {&#10;                        1: &quot;Temperatura Externa 1&quot;,&#10;                        2: &quot;Temperatura Externa 2&quot;,&#10;                        3: &quot;Temperatura Solo 1&quot;,&#10;                        4: &quot;Temperatura Solo 2&quot;,&#10;                        5: &quot;Temperatura Ar 1&quot;,&#10;                        6: &quot;Temperatura Ar 2&quot;,&#10;                        7: &quot;Umidade Ar 1&quot;,&#10;                        8: &quot;Umidade Ar 2&quot;,&#10;                        9: &quot;Umidade Solo&quot;,&#10;                        10: &quot;Radiação UV 1&quot;,&#10;                        11: &quot;Radiação UV 2&quot;,&#10;                        12: &quot;Velocidade Vento 1&quot;,&#10;                        13: &quot;Velocidade Vento 2&quot;&#10;                        },&#10;                'units': {&#10;                        1: &quot;°C&quot;, 2: &quot;°C&quot;, 3: &quot;°C&quot;, 4: &quot;°C&quot;, 5: &quot;°C&quot;, 6: &quot;°C&quot;,&#10;                        7: &quot;%&quot;, 8: &quot;%&quot;, 9: &quot;%&quot;,&#10;                        10: &quot;UV&quot;, 11: &quot;UV&quot;,&#10;                        12: &quot;m/s&quot;, 13: &quot;m/s&quot;&#10;                        }&#10;                }&#10;        return render(request, 'dashboard.html', context)&#10;    &#10;    except Exception as e:&#10;        import logging&#10;        logger = logging.getLogger(__name__)&#10;        logger.error(f&quot;Error in dashboard view: {str(e)}&quot;, exc_info = True)&#10;        return render(request, 'error.html', {'error': str(e)})&#10;&#10;&#10;def data_table(request):&#10;&#9;&quot;&quot;&quot;&#10;&#9;View showing paginated table with all sensor readings&#10;&#9;&quot;&quot;&quot;&#10;&#9;try:&#10;&#9;&#9;all_readings = SensorReading.objects.all().order_by('-timestamp')&#10;&#9;&#9;&#10;&#9;&#9;# Pagination - 50 items per page&#10;&#9;&#9;paginator = Paginator(all_readings, 50)&#10;&#9;&#9;page_number = request.GET.get('page')&#10;&#9;&#9;page_obj = paginator.get_page(page_number)&#10;&#9;&#9;&#10;&#9;&#9;context = {&#10;&#9;&#9;&#9;&#9;'page_obj': page_obj,&#10;&#9;&#9;&#9;&#9;'sensor_names': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;1: &quot;Temp 1&quot;, 2: &quot;Temp 2&quot;, 3: &quot;Temp 3&quot;, 4: &quot;Temp 4&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;5: &quot;Temp 5&quot;, 6: &quot;Temp 6&quot;, 7: &quot;Hum 1&quot;, 8: &quot;Hum 2&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;9: &quot;Hum 3&quot;, 10: &quot;UV 1&quot;, 11: &quot;UV 2&quot;, 12: &quot;Vento 1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;13: &quot;Vento 2&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;&#9;'units': {&#10;&#9;&#9;&#9;&#9;&#9;&#9;1: &quot;°C&quot;, 2: &quot;°C&quot;, 3: &quot;°C&quot;, 4: &quot;°C&quot;, 5: &quot;°C&quot;, 6: &quot;°C&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;7: &quot;%&quot;, 8: &quot;%&quot;, 9: &quot;%&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;10: &quot;UV&quot;, 11: &quot;UV&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;12: &quot;m/s&quot;, 13: &quot;m/s&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;return render(request, 'data_table.html', context)&#10;&#9;&#10;&#9;except Exception as e:&#10;&#9;&#9;import logging&#10;&#9;&#9;logger = logging.getLogger(__name__)&#10;&#9;&#9;logger.error(f&quot;Error in data_table view: {str(e)}&quot;, exc_info = True)&#10;&#9;&#9;return render(request, 'error.html', {'error': str(e)})&#10;&#10;&#10;def custom_error_view(request, exception = None):&#10;&#9;&quot;&quot;&quot;&#10;&#9;Custom error view that shows detailed technical information for debugging,&#10;&#9;while maintaining a user-friendly interface.&#10;&#9;&quot;&quot;&quot;&#10;&#9;# Get exception information&#10;&#9;exc_type, exc_value, exc_traceback = sys.exc_info()&#10;&#9;error_traceback = traceback.format_exception(exc_type, exc_value, exc_traceback)&#10;&#9;&#10;&#9;# Build context with detailed error information&#10;&#9;context = {&#10;&#9;&#9;&#9;'error_type': exc_type.__name__ if exc_type else 'Unknown Error',&#10;&#9;&#9;&#9;'error_message': str(exc_value) if exc_value else 'No error message available',&#10;&#9;&#9;&#9;'error_traceback': error_traceback,&#10;&#9;&#9;&#9;'timestamp': timezone.now(),&#10;&#9;&#9;&#9;'request_path': request.path,&#10;&#9;&#9;&#9;'request_method': request.method,&#10;&#9;&#9;&#9;'debug_mode': settings.DEBUG,&#10;&#9;&#9;&#9;}&#10;&#9;&#10;&#9;# Add additional debug information if in DEBUG mode&#10;&#9;if settings.DEBUG:&#10;&#9;&#9;from django.http import QueryDict&#10;&#9;&#9;context.update({&#10;&#9;&#9;&#9;&#9;'request_headers': dict(request.headers),&#10;&#9;&#9;&#9;&#9;'request_params': QueryDict(request.META.get('QUERY_STRING', '')),&#10;&#9;&#9;&#9;&#9;'request_post': request.POST if request.method == 'POST' else None,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#10;&#9;# Determine the status code&#10;&#9;status_code = 500&#10;&#9;if hasattr(exception, 'status_code'):&#10;&#9;&#9;status_code = exception.status_code&#10;&#9;context['status_code'] = status_code&#10;&#9;&#10;&#9;# Log the error&#10;&#9;logger.error(&#10;&#9;&#9;&#9;f&quot;Error {status_code} at {request.path}\n&quot;&#10;&#9;&#9;&#9;f&quot;Type: {context['error_type']}\n&quot;&#10;&#9;&#9;&#9;f&quot;Message: {context['error_message']}\n&quot;&#10;&#9;&#9;&#9;f&quot;Traceback:\n{''.join(error_traceback)}&quot;&#10;&#9;&#9;&#9;)&#10;&#9;&#10;&#9;return render(request, 'error.html', context, status = status_code)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/settings.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/settings.py" />
              <option name="originalContent" value="from pathlib import Path&#10;&#10;BASE_DIR = Path(__file__).resolve().parent.parent&#10;&#10;SECRET_KEY = 'django-insecure-tw9o&amp;ao7_0y!(@nkok_7$pd0ye2oq%rnr58&amp;$m8ay$ly5&amp;r2gs'&#10;&#10;DEBUG = True&#10;&#10;ALLOWED_HOSTS = ['*']&#10;&#10;INSTALLED_APPS = [&#10;    'django.contrib.admin',&#10;    'django.contrib.auth',&#10;    'django.contrib.contenttypes',&#10;    'django.contrib.sessions',&#10;    'django.contrib.messages',&#10;    'django.contrib.staticfiles',&#10;&#9;&#9;'app',  # seu app&#10;]&#10;&#10;MIDDLEWARE = [&#10;    'django.middleware.security.SecurityMiddleware',&#10;    'django.contrib.sessions.middleware.SessionMiddleware',&#10;    'django.middleware.common.CommonMiddleware',&#10;    'django.middleware.csrf.CsrfViewMiddleware',&#10;    'django.contrib.auth.middleware.AuthenticationMiddleware',&#10;    'django.contrib.messages.middleware.MessageMiddleware',&#10;    'django.middleware.clickjacking.XFrameOptionsMiddleware',&#10;]&#10;&#10;ROOT_URLCONF = 'config.urls'&#10;&#10;TEMPLATES = [&#10;    {&#10;        'BACKEND': 'django.template.backends.django.DjangoTemplates',&#10;        'DIRS': [BASE_DIR / 'templates'],  # Corrigido aqui&#10;        'APP_DIRS': True,&#10;        'OPTIONS': {&#10;            'context_processors': [&#10;                'django.template.context_processors.debug',&#10;                'django.template.context_processors.request',&#10;                'django.contrib.auth.context_processors.auth',&#10;                'django.contrib.messages.context_processors.messages',&#10;            ],&#10;        },&#10;    },&#10;]&#10;&#10;WSGI_APPLICATION = 'config.wsgi.application'&#10;&#10;DATABASES = {&#10;    'default': {&#10;        'ENGINE': 'django.db.backends.sqlite3',&#10;        'NAME': BASE_DIR / 'db.sqlite3',&#10;    }&#10;}&#10;&#10;AUTH_PASSWORD_VALIDATORS = []&#10;&#10;LANGUAGE_CODE = 'pt-br'&#10;TIME_ZONE = 'America/Sao_Paulo'&#10;&#10;USE_I18N = True&#10;USE_TZ = True&#10;&#10;STATIC_URL = '/static/'&#10;STATICFILES_DIRS = [BASE_DIR / &quot;static&quot;]&#10;&#10;DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'&#10;" />
              <option name="updatedContent" value="from pathlib import Path&#10;&#10;BASE_DIR = Path(__file__).resolve().parent.parent&#10;&#10;SECRET_KEY = 'django-insecure-tw9o&amp;ao7_0y!(@nkok_7$pd0ye2oq%rnr58&amp;$m8ay$ly5&amp;r2gs'&#10;&#10;DEBUG = True&#10;&#10;ALLOWED_HOSTS = ['*']&#10;&#10;INSTALLED_APPS = [&#10;    'django.contrib.admin',&#10;    'django.contrib.auth',&#10;    'django.contrib.contenttypes',&#10;    'django.contrib.sessions',&#10;    'django.contrib.messages',&#10;    'django.contrib.staticfiles',&#10;&#9;&#9;'app',  # seu app&#10;]&#10;&#10;MIDDLEWARE = [&#10;    'django.middleware.security.SecurityMiddleware',&#10;    'django.contrib.sessions.middleware.SessionMiddleware',&#10;    'django.middleware.common.CommonMiddleware',&#10;    'django.middleware.csrf.CsrfViewMiddleware',&#10;    'django.contrib.auth.middleware.AuthenticationMiddleware',&#10;    'django.contrib.messages.middleware.MessageMiddleware',&#10;    'django.middleware.clickjacking.XFrameOptionsMiddleware',&#10;]&#10;&#10;ROOT_URLCONF = 'config.urls'&#10;&#10;TEMPLATES = [&#10;    {&#10;        'BACKEND': 'django.template.backends.django.DjangoTemplates',&#10;        'DIRS': [str(BASE_DIR / 'templates')],  # Garante que o caminho é string&#10;        'APP_DIRS': True,&#10;        'OPTIONS': {&#10;            'context_processors': [&#10;                'django.template.context_processors.debug',&#10;                'django.template.context_processors.request',&#10;                'django.contrib.auth.context_processors.auth',&#10;                'django.contrib.messages.context_processors.messages',&#10;            ],&#10;        },&#10;    },&#10;]&#10;&#10;WSGI_APPLICATION = 'config.wsgi.application'&#10;&#10;DATABASES = {&#10;    'default': {&#10;        'ENGINE': 'django.db.backends.sqlite3',&#10;        'NAME': BASE_DIR / 'db.sqlite3',&#10;    }&#10;}&#10;&#10;AUTH_PASSWORD_VALIDATORS = []&#10;&#10;LANGUAGE_CODE = 'pt-br'&#10;TIME_ZONE = 'America/Sao_Paulo'&#10;&#10;USE_I18N = True&#10;USE_TZ = True&#10;&#10;STATIC_URL = '/static/'&#10;STATICFILES_DIRS = [BASE_DIR / &quot;static&quot;]&#10;&#10;DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hardware/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hardware/main.cpp" />
              <option name="originalContent" value="/*&#10; * Código ESP32 para envio de dados de sensores ao servidor Django&#10; * Compatível com a view receive_sensor_data do Django&#10; * Este código permite que um dispositivo ESP32 colete dados simulados de vários sensores e envie essas informações para um servidor Django via HTTP POST.&#10; *&#10; * FUNCIONALIDADES:&#10; * - Conexão Wi-Fi com rede configurada&#10; * - Simulação de 13 tipos de sensores (temperatura, umidade, UV, vento)&#10; * - Simulação de nível de bateria entre 30% e 100%&#10; * - Envio de dados ao servidor Django em intervalos regulares (a cada 5 minutos)&#10; * - Exibição de informações do dispositivo (MAC, IP, etc.)&#10; *&#10; * CONFIGURAÇÃO:&#10; * - Definir credenciais Wi-Fi (SSID e senha)&#10; * - Definir a URL do servidor Django para receber os dados&#10; * - Intervalo de envio configurado para 5 minutos (300000 ms)&#10; *&#10; * EXEMPLO DE DADOS ENVIADOS:&#10; * - Sensor 1 a 6: Temperatura simulada (DS18B20)&#10; * - Sensor 7 a 9: Umidade simulada (DHT11)&#10; * - Sensor 10 a 11: UV simulada (GYML8511)&#10; * - Sensor 12 a 13: Velocidade do vento simulada (Anemômetro)&#10; */&#10;&#10;#include &lt;WiFi.h&gt;&#10;#include &lt;HTTPClient.h&gt;&#10;#include &lt;WiFiClient.h&gt;&#10;#include &lt;ArduinoJson.h&gt;&#10;#include &lt;WiFiUdp.h&gt;&#10;&#10;///// CONFIGURAÇÕES DE REDE /////&#10;const char* ssid = &quot;ap-sl1109&quot;;              // Nome da rede Wi-Fi&#10;const char* password = &quot;danielgremista&quot;;       // Senha da rede Wi-Fi&#10;&#10;// Endpoints do servidor Django&#10;const char* serverUrl = &quot;http://10.5.1.113:8000/api/receive/&quot;; // URL para receber dados do sensor&#10;&#10;///// INTERVALOS DE ENVIO /////&#10;const unsigned long postingInterval = 30000;  // Intervalo de 5 minutos para envio de dados&#10;unsigned long lastSendTime = 0;                // Armazena o último tempo de envio&#10;&#10;///// FUNÇÕES PRINCIPAIS /////&#10;void connectToWiFi();&#10;void readSimulatedSensors(float* values);&#10;float simulateBatteryLevel();&#10;void sendSensorData(float* sensorValues, float batteryLevel);&#10;void printDeviceInfo();&#10;//&amp; Função de inicialização (setup) do dispositivo.&#10;void setup() {&#10;  Serial.begin(115200);                      // Inicia a comunicação serial&#10;  Serial.println(&quot;\nIniciando dispositivo...&quot;);&#10;&#10;  connectToWiFi(); // Conecta ao Wi-Fi&#10;  printDeviceInfo(); // Exibe informações do dispositivo&#10;&#10;  // Diagnóstico extra: teste de conexão HTTP ao servidor&#10;  Serial.println(&quot;Testando conexão HTTP com o servidor...&quot;);&#10;  HTTPClient http;&#10;  http.begin(serverUrl);&#10;  int httpCode = http.GET();&#10;  if (httpCode &gt; 0) {&#10;    Serial.printf(&quot;Conexão HTTP estabelecida! Código: %d\n&quot;, httpCode);&#10;    String payload = http.getString();&#10;    Serial.println(&quot;Resposta do servidor: &quot; + payload);&#10;  } else {&#10;    Serial.printf(&quot;Falha na conexão HTTP! Código: %d\n&quot;, httpCode);&#10;    Serial.println(&quot;Verifique se o servidor está rodando e acessível pelo IP/porta.&quot;);&#10;  }&#10;  http.end();&#10;}&#10;&#10;//&amp; Função principal que é chamada repetidamente para verificar a conexão e enviar dados.&#10;void loop() {&#10;  // Verifica a conexão Wi-Fi periodicamente&#10;  if (WiFi.status() != WL_CONNECTED) {&#10;    Serial.println(&quot;WiFi desconectado! Reconectando...&quot;);&#10;    connectToWiFi();  // Reconecta ao Wi-Fi caso a conexão seja perdida&#10;  }&#10;&#10;  //&amp; Envia dados no intervalo configurado&#10;  if (millis() - lastSendTime &gt; postingInterval) {&#10;    //&amp; Simula a leitura dos sensores&#10;    float sensorValues[13];&#10;    readSimulatedSensors(sensorValues);  // Função que gera os dados simulados&#10;&#10;    float batteryLevel = simulateBatteryLevel();  // Simula o nível de bateria (de 0 a 100%)&#10;&#10;    sendSensorData(sensorValues, batteryLevel); // Envia os dados ao servidor Django&#10;&#10;    lastSendTime = millis(); // Atualiza o tempo da última transmissão de dados&#10;  }&#10;&#10;  delay(1000);  // Pequeno delay entre verificações&#10;}&#10;&#10;//&amp; Função que conecta o dispositivo ao Wi-Fi utilizando as credenciais fornecidas.&#10;void connectToWiFi() {&#10;  Serial.print(&quot;Conectando a &quot;);&#10;  Serial.println(ssid);&#10;&#10;  WiFi.begin(ssid, password);&#10;&#10;  int attempts = 0;&#10;  while (WiFi.status() != WL_CONNECTED &amp;&amp; attempts &lt; 20) {  // Tenta se conectar até 20 vezes&#10;    delay(500);&#10;    Serial.print(&quot;.&quot;);&#10;    attempts++;&#10;  }&#10;&#10;  if (WiFi.status() == WL_CONNECTED) {&#10;    Serial.println(&quot;\nConectado com sucesso!&quot;);&#10;    Serial.print(&quot;Endereço IP: &quot;);&#10;    Serial.println(WiFi.localIP());  // Exibe o IP atribuído ao dispositivo&#10;  } else {&#10;    Serial.println(&quot;\nFalha na conexão WiFi&quot;);&#10;  }&#10;}&#10;&#10;//&amp; Função que exibe as informações do dispositivo, como MAC Address e IP local.&#10;void printDeviceInfo() {&#10;  Serial.println(&quot;\n=== Informações do Dispositivo ===&quot;);&#10;  Serial.print(&quot;MAC Address: &quot;);&#10;  Serial.println(WiFi.macAddress());        // Exibe o MAC Address do dispositivo&#10;  Serial.print(&quot;Endereço IP: &quot;);&#10;  Serial.println(WiFi.localIP());           // Exibe o IP local do dispositivo&#10;  Serial.printf(&quot;Intervalo de envio: %d minutos\n&quot;, postingInterval / 60000);  // Exibe o intervalo de envio&#10;  Serial.println(&quot;=================================\n&quot;);&#10;}&#10;&#10;//&amp; Função que simula a leitura de 13 sensores e preenche um vetor com os valores simulados.&#10;//&amp; Simula sensores de temperatura (DS18B20), umidade (DHT11), UV (GYML8511) e velocidade do vento (Anemômetro).&#10;//&amp; @param values Vetor para armazenar os valores simulados dos sensores.&#10;void readSimulatedSensors(float* values) {&#10;  // Gera valores simulados para os 13 sensores&#10;  for (int i = 0; i &lt; 13; i++) {&#10;    if (i &lt; 6) { // Sensores 1 a 6 - Simulação de temperatura (DS18B20)&#10;      values[i] = 20.0 + (i * 0.5) + (random(0, 10) / 10.0);  // Temperatura entre 20 e 23°C&#10;    }&#10;    else if (i &lt; 9) { // Sensores 7 a 9 - Simulação de umidade (DHT11)&#10;      values[i] = 50.0 + (i * 2) + random(0, 10);  // Umidade entre 50 e 60%&#10;    }&#10;    else if (i &lt; 11) { // Sensores 10 a 11 - Simulação de UV (GYML8511)&#10;      values[i] = 1.0 + (i * 0.3) + (random(0, 5) / 10.0);  // UV entre 1.0 e 1.6&#10;    }&#10;    else { // Sensores 12 e 13 - Simulação de velocidade do vento (Anemômetro)&#10;      values[i] = 0.5 + (i * 0.2) + (random(0, 8) / 10.0);  // Velocidade do vento entre 0.5 e 1.0 m/s&#10;    }&#10;  }&#10;&#10;  //&amp; Exibe os valores no serial para depuração&#10;  Serial.println(&quot;Valores simulados dos sensores:&quot;);&#10;  for (int i = 0; i &lt; 13; i++) {&#10;    Serial.printf(&quot;Sensor %d: %.2f\n&quot;, i+1, values[i]);&#10;  }&#10;}&#10;&#10;//&amp; Função que simula o nível de bateria, retornando um valor aleatório entre 30% e 100%.&#10;//&amp; @return Nível de bateria simulado.&#10;float simulateBatteryLevel() {&#10;  //&amp; Simula bateria entre 30% e 100%&#10;  float level = 30.0 + random(0, 70);  // Gera um valor entre 30 e 100%&#10;  Serial.printf(&quot;Nível de bateria simulado: %.1f%%\n&quot;, level);&#10;  return level;&#10;}&#10;&#10;//&amp; Função que envia os dados dos sensores e o nível de bateria para o servidor Django via HTTP POST.&#10;//&amp; @param sensorValues Valores simulados dos 13 sensores.&#10;//&amp; @param batteryLevel Nível de bateria do dispositivo.&#10;&#10;void sendSensorData(float* sensorValues, float batteryLevel) {&#10;  if (WiFi.status() != WL_CONNECTED) {  // Verifica se o Wi-Fi está desconectado&#10;    Serial.println(&quot;WiFi desconectado!&quot;);&#10;    connectToWiFi();  // Reconnecta ao Wi-Fi&#10;    return;&#10;  }&#10;&#10;  HTTPClient http;               // Cria um cliente HTTP&#10;  http.begin(serverUrl);         // Inicia a requisição para o servidor Django&#10;  http.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);  // Define o tipo de conteúdo como JSON&#10;&#10;  JsonDocument doc;  // Cria o documento JSON para armazenar os dados&#10;&#10;  //&amp; Adiciona os valores dos sensores ao JSON&#10;  for (int i = 0; i &lt; 13; i++) {&#10;    char sensorKey[10];&#10;    sprintf(sensorKey, &quot;sensor%d&quot;, i+1);  // Cria uma chave para cada sensor&#10;    doc[sensorKey] = sensorValues[i];  // Adiciona o valor do sensor ao documento JSON&#10;  }&#10;&#10;  //&amp; Adiciona metadados (ID do dispositivo e nível de bateria)&#10;  doc[&quot;device_id&quot;] = WiFi.macAddress();  // Adiciona o MAC Address do dispositivo&#10;  doc[&quot;battery&quot;] = batteryLevel;         // Adiciona o nível de bateria ao JSON&#10;&#10;  //&amp; Serializa o JSON em uma string e envia&#10;  String payload;&#10;  serializeJson(doc, payload);  // Converte o JSON para uma string&#10;&#10;  int httpCode = http.POST(payload);  // Envia a requisição HTTP POST com os dados&#10;&#10;  if (httpCode == HTTP_CODE_OK) {&#10;    String response = http.getString();&#10;    Serial.println(&quot;✅ Dados enviados com sucesso ao servidor!&quot;);&#10;    Serial.println(&quot; Resposta do servidor: &quot; + response);&#10;} else {&#10;    Serial.println(&quot;❌ Erro ao enviar dados para o servidor:&quot;);&#10;&#10;    // Detailed error messages&#10;    switch(httpCode) {&#10;        case -1:&#10;            Serial.println(&quot;Falha na conexão - Verifique:&quot;);&#10;            Serial.println(&quot;      • Se o servidor está rodando&quot;);&#10;            Serial.println(&quot;      • Se o IP/porta estão corretos&quot;);&#10;            Serial.println(&quot;      • Se o WiFi está estável&quot;);&#10;            break;&#10;        case HTTPC_ERROR_CONNECTION_LOST:&#10;            Serial.println(&quot;Conexão recusada - Servidor pode estar offline ou porta bloqueada&quot;);&#10;            break;&#10;        case HTTPC_ERROR_SEND_HEADER_FAILED:&#10;            Serial.println(&quot;alha ao enviar cabeçalhos - Problema na rede&quot;);&#10;            break;&#10;        case HTTPC_ERROR_SEND_PAYLOAD_FAILED:&#10;            Serial.println(&quot;    Falha ao enviar dados - Rede instável&quot;);&#10;            break;&#10;        case HTTPC_ERROR_NOT_CONNECTED:&#10;            Serial.println(&quot;WiFi desconectado - Reconectando...&quot;);&#10;            connectToWiFi(); // Attempt to reconnect&#10;            break;&#10;        case HTTPC_ERROR_READ_TIMEOUT:&#10;            Serial.println(&quot; Timeout excedido - Servidor não respondeu a tempo&quot;);&#10;            break;&#10;        case 400:&#10;            Serial.println(&quot; Erro 400 (Bad Request) - Verifique o formato dos dados&quot;);&#10;            break;&#10;        case 401:&#10;            Serial.println(&quot;Erro 401 (Unauthorized) - Falha na autenticação&quot;);&#10;            break;&#10;        case 404:&#10;            Serial.println(&quot; Erro 404 (Not Found) - URL do endpoint incorreta&quot;);&#10;            Serial.println(&quot;      Endpoint atual: &quot; + String(serverUrl));&#10;            break;&#10;        case 500:&#10;            Serial.println(&quot;Erro 500 (Server Error) - Problema no servidor Django&quot;);&#10;            break;&#10;        default:&#10;            Serial.print(&quot;Código de erro HTTP: &quot;);&#10;            Serial.println(httpCode);&#10;    }&#10;&#10;    // Get server response if available&#10;    if (httpCode &gt; 0) {&#10;        String errorResponse = http.getString();&#10;        if (errorResponse.length() &gt; 0) {&#10;            Serial.println(&quot;Resposta do servidor: &quot; + errorResponse);&#10;        }&#10;    }&#10;&#10;    // Network diagnostics&#10;    Serial.println(&quot;\nDiagnóstico de rede:&quot;);&#10;    Serial.println(&quot;Força do sinal WiFi: &quot; + String(WiFi.RSSI()) + &quot; dBm&quot;);&#10;    Serial.println(&quot;IP local: &quot; + WiFi.localIP().toString());&#10;    Serial.println(&quot;IP do servidor: &quot; + String(serverUrl));&#10;}&#10;&#10;  http.end();  // Finaliza a requisição HTTP&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * Código ESP32 para envio de dados de sensores ao servidor Django&#10; * Compatível com a view receive_sensor_data do Django&#10; * Este código permite que um dispositivo ESP32 colete dados simulados de vários sensores e envie essas informações para um servidor Django via HTTP POST.&#10; *&#10; * FUNCIONALIDADES:&#10; * - Conexão Wi-Fi com rede configurada&#10; * - Simulação de 13 tipos de sensores (temperatura, umidade, UV, vento)&#10; * - Simulação de nível de bateria entre 30% e 100%&#10; * - Envio de dados ao servidor Django em intervalos regulares (a cada 5 minutos)&#10; * - Exibição de informações do dispositivo (MAC, IP, etc.)&#10; *&#10; * CONFIGURAÇÃO:&#10; * - Definir credenciais Wi-Fi (SSID e senha)&#10; * - Definir a URL do servidor Django para receber os dados&#10; * - Intervalo de envio configurado para 5 minutos (300000 ms)&#10; *&#10; * EXEMPLO DE DADOS ENVIADOS:&#10; * - Sensor 1 a 6: Temperatura simulada (DS18B20)&#10; * - Sensor 7 a 9: Umidade simulada (DHT11)&#10; * - Sensor 10 a 11: UV simulada (GYML8511)&#10; * - Sensor 12 a 13: Velocidade do vento simulada (Anemômetro)&#10; */&#10;&#10;#include &lt;WiFi.h&gt;&#10;#include &lt;HTTPClient.h&gt;&#10;#include &lt;WiFiClient.h&gt;&#10;#include &lt;ArduinoJson.h&gt;&#10;#include &lt;WiFiUdp.h&gt;&#10;&#10;///// CONFIGURAÇÕES DE REDE /////&#10;const char* ssid = &quot;ap-sl1109&quot;;              // Nome da rede Wi-Fi&#10;const char* password = &quot;danielgremista&quot;;       // Senha da rede Wi-Fi&#10;&#10;// Endpoints do servidor Django&#10;const char* serverUrl = &quot;http://10.5.1.113:8000/api/receive/&quot;; // URL para receber dados do sensor&#10;&#10;///// INTERVALOS DE ENVIO /////&#10;const unsigned long postingInterval = 30000;  // Intervalo de 5 minutos para envio de dados&#10;unsigned long lastSendTime = 0;                // Armazena o último tempo de envio&#10;&#10;///// FUNÇÕES PRINCIPAIS /////&#10;void connectToWiFi();&#10;void readSimulatedSensors(float* values);&#10;float simulateBatteryLevel();&#10;void sendSensorData(float* sensorValues, float batteryLevel);&#10;void printDeviceInfo();&#10;//&amp; Função de inicialização (setup) do dispositivo.&#10;void setup() {&#10;  Serial.begin(115200);                      // Inicia a comunicação serial&#10;  Serial.println(&quot;\nIniciando dispositivo...&quot;);&#10;&#10;  connectToWiFi(); // Conecta ao Wi-Fi&#10;  printDeviceInfo(); // Exibe informações do dispositivo&#10;&#10;  // Diagnóstico extra: teste de conexão TCP antes do HTTP&#10;  Serial.println(&quot;Testando conexão TCP com o servidor...&quot;);&#10;  WiFiClient tcpClient;&#10;  if (tcpClient.connect(&quot;10.5.1.113&quot;, 8000)) {&#10;    Serial.println(&quot;Conexão TCP estabelecida com o servidor!&quot;);&#10;    tcpClient.stop();&#10;  } else {&#10;    Serial.println(&quot;Falha na conexão TCP! Verifique IP, porta e rede.&quot;);&#10;  }&#10;&#10;  // Diagnóstico extra: teste de conexão HTTP ao servidor&#10;  Serial.println(&quot;Testando conexão HTTP com o servidor...&quot;);&#10;  HTTPClient http;&#10;  http.begin(serverUrl);&#10;  int httpCode = http.GET();&#10;  if (httpCode &gt; 0) {&#10;    Serial.printf(&quot;Conexão HTTP estabelecida! Código: %d\n&quot;, httpCode);&#10;    String payload = http.getString();&#10;    Serial.println(&quot;Resposta do servidor: &quot; + payload);&#10;  } else {&#10;    Serial.printf(&quot;Falha na conexão HTTP! Código: %d\n&quot;, httpCode);&#10;    Serial.println(&quot;Verifique se o servidor está rodando e acessível pelo IP/porta.&quot;);&#10;  }&#10;  http.end();&#10;}&#10;&#10;//&amp; Função principal que é chamada repetidamente para verificar a conexão e enviar dados.&#10;void loop() {&#10;  // Verifica a conexão Wi-Fi periodicamente&#10;  if (WiFi.status() != WL_CONNECTED) {&#10;    Serial.println(&quot;WiFi desconectado! Reconectando...&quot;);&#10;    connectToWiFi();  // Reconecta ao Wi-Fi caso a conexão seja perdida&#10;  }&#10;&#10;  //&amp; Envia dados no intervalo configurado&#10;  if (millis() - lastSendTime &gt; postingInterval) {&#10;    //&amp; Simula a leitura dos sensores&#10;    float sensorValues[13];&#10;    readSimulatedSensors(sensorValues);  // Função que gera os dados simulados&#10;&#10;    float batteryLevel = simulateBatteryLevel();  // Simula o nível de bateria (de 0 a 100%)&#10;&#10;    sendSensorData(sensorValues, batteryLevel); // Envia os dados ao servidor Django&#10;&#10;    lastSendTime = millis(); // Atualiza o tempo da última transmissão de dados&#10;  }&#10;&#10;  delay(1000);  // Pequeno delay entre verificações&#10;}&#10;&#10;//&amp; Função que conecta o dispositivo ao Wi-Fi utilizando as credenciais fornecidas.&#10;void connectToWiFi() {&#10;  Serial.print(&quot;Conectando a &quot;);&#10;  Serial.println(ssid);&#10;&#10;  WiFi.begin(ssid, password);&#10;&#10;  int attempts = 0;&#10;  while (WiFi.status() != WL_CONNECTED &amp;&amp; attempts &lt; 20) {  // Tenta se conectar até 20 vezes&#10;    delay(500);&#10;    Serial.print(&quot;.&quot;);&#10;    attempts++;&#10;  }&#10;&#10;  if (WiFi.status() == WL_CONNECTED) {&#10;    Serial.println(&quot;\nConectado com sucesso!&quot;);&#10;    Serial.print(&quot;Endereço IP: &quot;);&#10;    Serial.println(WiFi.localIP());  // Exibe o IP atribuído ao dispositivo&#10;  } else {&#10;    Serial.println(&quot;\nFalha na conexão WiFi&quot;);&#10;  }&#10;}&#10;&#10;//&amp; Função que exibe as informações do dispositivo, como MAC Address e IP local.&#10;void printDeviceInfo() {&#10;  Serial.println(&quot;\n=== Informações do Dispositivo ===&quot;);&#10;  Serial.print(&quot;MAC Address: &quot;);&#10;  Serial.println(WiFi.macAddress());        // Exibe o MAC Address do dispositivo&#10;  Serial.print(&quot;Endereço IP: &quot;);&#10;  Serial.println(WiFi.localIP());           // Exibe o IP local do dispositivo&#10;  Serial.printf(&quot;Intervalo de envio: %d minutos\n&quot;, postingInterval / 60000);  // Exibe o intervalo de envio&#10;  Serial.println(&quot;=================================\n&quot;);&#10;}&#10;&#10;//&amp; Função que simula a leitura de 13 sensores e preenche um vetor com os valores simulados.&#10;//&amp; Simula sensores de temperatura (DS18B20), umidade (DHT11), UV (GYML8511) e velocidade do vento (Anemômetro).&#10;//&amp; @param values Vetor para armazenar os valores simulados dos sensores.&#10;void readSimulatedSensors(float* values) {&#10;  // Gera valores simulados para os 13 sensores&#10;  for (int i = 0; i &lt; 13; i++) {&#10;    if (i &lt; 6) { // Sensores 1 a 6 - Simulação de temperatura (DS18B20)&#10;      values[i] = 20.0 + (i * 0.5) + (random(0, 10) / 10.0);  // Temperatura entre 20 e 23°C&#10;    }&#10;    else if (i &lt; 9) { // Sensores 7 a 9 - Simulação de umidade (DHT11)&#10;      values[i] = 50.0 + (i * 2) + random(0, 10);  // Umidade entre 50 e 60%&#10;    }&#10;    else if (i &lt; 11) { // Sensores 10 a 11 - Simulação de UV (GYML8511)&#10;      values[i] = 1.0 + (i * 0.3) + (random(0, 5) / 10.0);  // UV entre 1.0 e 1.6&#10;    }&#10;    else { // Sensores 12 e 13 - Simulação de velocidade do vento (Anemômetro)&#10;      values[i] = 0.5 + (i * 0.2) + (random(0, 8) / 10.0);  // Velocidade do vento entre 0.5 e 1.0 m/s&#10;    }&#10;  }&#10;&#10;  //&amp; Exibe os valores no serial para depuração&#10;  Serial.println(&quot;Valores simulados dos sensores:&quot;);&#10;  for (int i = 0; i &lt; 13; i++) {&#10;    Serial.printf(&quot;Sensor %d: %.2f\n&quot;, i+1, values[i]);&#10;  }&#10;}&#10;&#10;//&amp; Função que simula o nível de bateria, retornando um valor aleatório entre 30% e 100%.&#10;//&amp; @return Nível de bateria simulado.&#10;float simulateBatteryLevel() {&#10;  //&amp; Simula bateria entre 30% e 100%&#10;  float level = 30.0 + random(0, 70);  // Gera um valor entre 30 e 100%&#10;  Serial.printf(&quot;Nível de bateria simulado: %.1f%%\n&quot;, level);&#10;  return level;&#10;}&#10;&#10;//&amp; Função que envia os dados dos sensores e o nível de bateria para o servidor Django via HTTP POST.&#10;//&amp; @param sensorValues Valores simulados dos 13 sensores.&#10;//&amp; @param batteryLevel Nível de bateria do dispositivo.&#10;&#10;void sendSensorData(float* sensorValues, float batteryLevel) {&#10;  if (WiFi.status() != WL_CONNECTED) {  // Verifica se o Wi-Fi está desconectado&#10;    Serial.println(&quot;WiFi desconectado!&quot;);&#10;    connectToWiFi();  // Reconnecta ao Wi-Fi&#10;    return;&#10;  }&#10;&#10;  HTTPClient http;               // Cria um cliente HTTP&#10;  http.begin(serverUrl);         // Inicia a requisição para o servidor Django&#10;  http.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);  // Define o tipo de conteúdo como JSON&#10;&#10;  JsonDocument doc;  // Cria o documento JSON para armazenar os dados&#10;&#10;  //&amp; Adiciona os valores dos sensores ao JSON&#10;  for (int i = 0; i &lt; 13; i++) {&#10;    char sensorKey[10];&#10;    sprintf(sensorKey, &quot;sensor%d&quot;, i+1);  // Cria uma chave para cada sensor&#10;    doc[sensorKey] = sensorValues[i];  // Adiciona o valor do sensor ao documento JSON&#10;  }&#10;&#10;  //&amp; Adiciona metadados (ID do dispositivo e nível de bateria)&#10;  doc[&quot;device_id&quot;] = WiFi.macAddress();  // Adiciona o MAC Address do dispositivo&#10;  doc[&quot;battery&quot;] = batteryLevel;         // Adiciona o nível de bateria ao JSON&#10;&#10;  //&amp; Serializa o JSON em uma string e envia&#10;  String payload;&#10;  serializeJson(doc, payload);  // Converte o JSON para uma string&#10;&#10;  int httpCode = http.POST(payload);  // Envia a requisição HTTP POST com os dados&#10;&#10;  if (httpCode == HTTP_CODE_OK) {&#10;    String response = http.getString();&#10;    Serial.println(&quot;✅ Dados enviados com sucesso ao servidor!&quot;);&#10;    Serial.println(&quot; Resposta do servidor: &quot; + response);&#10;} else {&#10;    Serial.println(&quot;❌ Erro ao enviar dados para o servidor:&quot;);&#10;&#10;    // Detailed error messages&#10;    switch(httpCode) {&#10;        case -1:&#10;            Serial.println(&quot;Falha na conexão - Verifique:&quot;);&#10;            Serial.println(&quot;      • Se o servidor está rodando&quot;);&#10;            Serial.println(&quot;      • Se o IP/porta estão corretos&quot;);&#10;            Serial.println(&quot;      • Se o WiFi está estável&quot;);&#10;            break;&#10;        case HTTPC_ERROR_CONNECTION_LOST:&#10;            Serial.println(&quot;Conexão recusada - Servidor pode estar offline ou porta bloqueada&quot;);&#10;            break;&#10;        case HTTPC_ERROR_SEND_HEADER_FAILED:&#10;            Serial.println(&quot;alha ao enviar cabeçalhos - Problema na rede&quot;);&#10;            break;&#10;        case HTTPC_ERROR_SEND_PAYLOAD_FAILED:&#10;            Serial.println(&quot;    Falha ao enviar dados - Rede instável&quot;);&#10;            break;&#10;        case HTTPC_ERROR_NOT_CONNECTED:&#10;            Serial.println(&quot;WiFi desconectado - Reconectando...&quot;);&#10;            connectToWiFi(); // Attempt to reconnect&#10;            break;&#10;        case HTTPC_ERROR_READ_TIMEOUT:&#10;            Serial.println(&quot; Timeout excedido - Servidor não respondeu a tempo&quot;);&#10;            break;&#10;        case 400:&#10;            Serial.println(&quot; Erro 400 (Bad Request) - Verifique o formato dos dados&quot;);&#10;            break;&#10;        case 401:&#10;            Serial.println(&quot;Erro 401 (Unauthorized) - Falha na autenticação&quot;);&#10;            break;&#10;        case 404:&#10;            Serial.println(&quot; Erro 404 (Not Found) - URL do endpoint incorreta&quot;);&#10;            Serial.println(&quot;      Endpoint atual: &quot; + String(serverUrl));&#10;            break;&#10;        case 500:&#10;            Serial.println(&quot;Erro 500 (Server Error) - Problema no servidor Django&quot;);&#10;            break;&#10;        default:&#10;            Serial.print(&quot;Código de erro HTTP: &quot;);&#10;            Serial.println(httpCode);&#10;    }&#10;&#10;    // Get server response if available&#10;    if (httpCode &gt; 0) {&#10;        String errorResponse = http.getString();&#10;        if (errorResponse.length() &gt; 0) {&#10;            Serial.println(&quot;Resposta do servidor: &quot; + errorResponse);&#10;        }&#10;    }&#10;&#10;    // Network diagnostics&#10;    Serial.println(&quot;\nDiagnóstico de rede:&quot;);&#10;    Serial.println(&quot;Força do sinal WiFi: &quot; + String(WiFi.RSSI()) + &quot; dBm&quot;);&#10;    Serial.println(&quot;IP local: &quot; + WiFi.localIP().toString());&#10;    Serial.println(&quot;IP do servidor: &quot; + String(serverUrl));&#10;}&#10;&#10;  http.end();  // Finaliza a requisição HTTP&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>